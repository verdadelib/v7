// C:\Users\ADM\Desktop\USB MKT PRO V3\pages\zap.tsx
import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Textarea, TextareaProps } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { useToast } from "@/components/ui/use-toast";
import Sidebar from "@/components/ui/sidebar";
import ElementCard from "@/components/dashboard/ElementCard";
import { cn } from "@/lib/utils";
import { MessageSquare, ListChecks, Trash2 as IconTrash, Image as ImageIcon, Clock, Variable, Waypoints, HelpCircle, Phone, Users, Settings, BarChart2, Bot, Plus, FileText, RefreshCw, Send, RadioTower, UserCheck, LogOut, Smartphone, PlugZap, Unplug, Save, UploadCloud, DownloadCloud, Play, Square, Eye, Map, Share2, Pencil, Check, X, GripVertical, Copy as IconCopy, Filter, Layers, Activity, Workflow, Target, AlertCircle, Hourglass, Bell, ShieldCheck, UserCircle, Search } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { ReactFlow, MiniMap, Controls, Background, useNodesState, useEdgesState, addEdge, Node, Edge, OnConnect, BackgroundVariant, MarkerType, Position, Handle, NodeProps, XYPosition, useReactFlow, NodeToolbar, useStoreApi, ReactFlowProvider, ReactFlowInstance } from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import dynamic from 'next/dynamic';
import { ScrollArea } from '@/components/ui/scroll-area';

// Cor de destaque Neon
const NEON_COLOR = '#1E90FF';

// Estilos base
const baseButtonSelectStyle = `bg-[#141414] border-none text-white shadow-[3px_3px_6px_rgba(0,0,0,0.3),-3px_-3px_6px_rgba(255,255,255,0.05)] hover:shadow-[inset_2px_2px_4px_rgba(0,0,0,0.3),inset_-2px_-2px_4px_rgba(255,255,255,0.05)] hover:bg-[${NEON_COLOR}]/20 focus:shadow-[inset_2px_2px_4px_rgba(0,0,0,0.3),inset_-2px_-2px_4px_rgba(255,255,255,0.05)]`;
const baseCardStyle = `bg-[#141414] border-none shadow-[5px_5px_10px_rgba(0,0,0,0.4),-5px_-5px_10px_rgba(255,255,255,0.05)] rounded-lg`;
const baseInputInsetStyle = `bg-[#101010] border-none text-white placeholder:text-gray-500 shadow-[inset_2px_2px_4px_rgba(0,0,0,0.3),inset_-2px_-2px_4px_rgba(255,255,255,0.05)] focus:shadow-[3px_3px_6px_rgba(0,0,0,0.3),-3px_-3px_6px_rgba(255,255,255,0.05)] focus:ring-1 focus:ring-[${NEON_COLOR}]/50 focus:bg-[#141414]`;
const popoverContentStyle = `bg-[#1e2128] border-[${NEON_COLOR}]/30 text-white`;

// QR Code dinâmico
const QRCodeDynamic = dynamic(() => import('qrcode.react').then(mod => mod.QRCodeSVG), {
  ssr: false,
  loading: () => <p className="text-xs text-gray-400" style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}>Carregando QR Code...</p>
});

// --- Tipos e Interfaces ---
type CampaignSelectItem = { id: string; name: string; };
type FlowData = { id: number; name: string; status: 'active' | 'inactive' | 'draft'; campaign_id?: string | null; elements?: { nodes: Node<any>[]; edges: Edge[] }; updated_at?: string; };
interface TextMessageData { text: string; }
interface ButtonOption { id: string; text: string; }
interface ButtonMessageData { text: string; buttons: ButtonOption[]; footer?: string; }
interface ImageData { url: string; caption?: string; }
interface DelayData { duration: number; unit: 'seconds' | 'minutes'; }
interface ListItem { id: string; title: string; description?: string; }
interface ListSection { id: string; title: string; rows: ListItem[]; }
interface ListMessageData { buttonText: string; title: string; text: string; sections: ListSection[]; footer?: string; }
interface WaitInputData { variableName: string; message?: string; timeoutSeconds?: number; }
interface SetVariableData { variableName: string; value: string; }
interface ConditionData { variableName: string; comparison: 'equals' | 'contains' | 'startsWith' | 'isSet' | 'isNotSet' | 'greaterThan' | 'lessThan'; value?: string; }
interface ApiCallData { apiUrl: string; method: 'GET' | 'POST' | 'PUT' | 'DELETE'; headers?: string; body?: string; saveResponseTo?: string; }
interface AssignAgentData { department?: string; agentId?: string; message?: string; }
interface EndFlowData { reason?: string; }
interface GoToFlowData { targetFlowId: number | string; }
interface TagContactData { tagName: string; action: 'add' | 'remove'; }
interface AppSettings { defaultMessageDelayMs: number; unknownMessageResponse: 'ignore' | 'defaultReply' | 'forwardAdmin'; defaultReplyMessage: string; adminForwardNumber: string; defaultInputTimeoutSeconds: number; enableBusinessHours: boolean; businessHoursStart: string; businessHoursEnd: string; outsideHoursMessage: string; }
interface Contact { jid: string; name?: string; notify?: string; imgUrl?: string; }

// --- Componentes Auxiliares de Estilo ---
const NodeInput = (props: React.ComponentProps<typeof Input>) => <Input {...props} className={cn(baseInputInsetStyle, "text-[10px] h-6 px-1 py-0.5 rounded-sm", props.className)} />;
const NodeLabel = (props: React.ComponentProps<typeof Label>) => <Label {...props} className={cn("text-[9px] text-gray-400 mb-0.5 block", props.className)} style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}/>;
const NodeButton = (props: React.ComponentProps<typeof Button>) => <Button variant="outline" size="xs" {...props} className={cn(baseButtonSelectStyle, `text-[9px] h-5 w-full rounded`, props.className)} style={{ textShadow: `0 0 4px ${NEON_COLOR}` }} />;
const NodeSelect = ({ children, ...props }: React.ComponentProps<typeof Select> & { placeholder?: string }) => ( <Select {...props}> <SelectTrigger className={cn(baseButtonSelectStyle, "h-6 text-[10px] rounded")}> <SelectValue placeholder={props.placeholder || 'Selecione...'} /> </SelectTrigger> <SelectContent className={cn(popoverContentStyle, "text-xs")}> {children} </SelectContent> </Select> );
export interface NodeTextareaProps extends TextareaProps {}
const NodeTextarea = React.forwardRef<HTMLTextAreaElement, NodeTextareaProps>( ({ className, ...props }, ref) => { return ( <Textarea ref={ref} className={cn( baseInputInsetStyle, "text-[10px] resize-none overflow-hidden min-h-[30px] p-1 rounded-sm", className )} rows={1} {...props} /> ) } ); NodeTextarea.displayName = "NodeTextarea";
const IconWithGlow: React.FC<{ icon: React.ElementType, className?: string }> = ({ icon: Icon, className }) => ( <Icon className={cn("node-icon", className)} style={{ filter: `drop-shadow(0 0 3px ${NEON_COLOR}99)` }} /> );

// --- Definições dos Componentes de Nó ---
function TextMessageNode({ id, data }: NodeProps<TextMessageData>) { const { setNodes } = useReactFlow(); const [text, setText] = useState(data?.text || ''); const textAreaRef = useRef<HTMLTextAreaElement>(null); const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { const newText = e.target.value; setText(newText); setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, text: newText } } : n)); if (textAreaRef.current) { textAreaRef.current.style.height = 'auto'; textAreaRef.current.style.height = `${textAreaRef.current.scrollHeight}px`; } }; useEffect(() => { if (textAreaRef.current) { textAreaRef.current.style.height = 'auto'; textAreaRef.current.style.height = `${textAreaRef.current.scrollHeight}px`; } }, []); return ( <Card className={cn(baseCardStyle, "node-card w-48")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600" /> <CardHeader className="node-header"> <div className="node-header-icon-title"><IconWithGlow icon={MessageSquare} /> Mensagem</div> </CardHeader> <CardContent className="p-2"> <NodeTextarea ref={textAreaRef} value={text} onChange={handleChange} placeholder="Sua mensagem..." /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function ButtonMessageNode({ id, data }: NodeProps<ButtonMessageData>) { const { setNodes } = useReactFlow(); const [text, setText] = useState(data?.text || ''); const [footer, setFooter] = useState(data?.footer || ''); const [buttons, setButtons] = useState<ButtonOption[]>(data?.buttons || [{ id: `btn_${Date.now()}`, text: 'Opção 1' }]); const textAreaRef = useRef<HTMLTextAreaElement>(null); const footerAreaRef = useRef<HTMLTextAreaElement>(null); const updateNodeData = (newData: Partial<ButtonMessageData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { const newText = e.target.value; setText(newText); updateNodeData({ text: newText }); if (textAreaRef.current) { textAreaRef.current.style.height = 'auto'; textAreaRef.current.style.height = `${textAreaRef.current.scrollHeight}px`; } }; const handleFooterChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { const newFooter = e.target.value; setFooter(newFooter); updateNodeData({ footer: newFooter }); if (footerAreaRef.current) { footerAreaRef.current.style.height = 'auto'; footerAreaRef.current.style.height = `${footerAreaRef.current.scrollHeight}px`; }}; const handleButtonChange = (buttonId: string, newText: string) => { const newButtons = buttons.map(b => b.id === buttonId ? { ...b, text: newText } : b); setButtons(newButtons); updateNodeData({ buttons: newButtons }); }; const addButton = () => { const newButtonId = `btn_${Date.now()}_${Math.random().toString(16).substring(2, 6)}`; const newButtons = [...buttons, { id: newButtonId, text: `Opção ${buttons.length + 1}` }]; setButtons(newButtons); updateNodeData({ buttons: newButtons }); }
const removeButton = (buttonId: string) => { const newButtons = buttons.filter(b => b.id !== buttonId); setButtons(newButtons); updateNodeData({ buttons: newButtons }); }
useEffect(() => { if (textAreaRef.current) { textAreaRef.current.style.height = 'auto'; textAreaRef.current.style.height = `${textAreaRef.current.scrollHeight}px`; } if (footerAreaRef.current) { footerAreaRef.current.style.height = 'auto'; footerAreaRef.current.style.height = `${footerAreaRef.current.scrollHeight}px`; }}, []); return ( <Card className={cn(baseCardStyle, "node-card w-56")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={ListChecks} /> Botões</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Mensagem</NodeLabel> <NodeTextarea ref={textAreaRef} value={text} onChange={handleTextChange} placeholder="Mensagem com botões..." /> <NodeLabel>Rodapé (Opcional)</NodeLabel> <NodeTextarea ref={footerAreaRef} value={footer} onChange={handleFooterChange} placeholder="Texto rodapé..." /> <NodeLabel>Botões</NodeLabel> <div className='space-y-1 max-h-24 overflow-y-auto pr-1 custom-scrollbar'> {buttons.map((button, index) => ( <div key={button.id} className='relative group flex items-center'> <NodeInput value={button.text} onChange={(e) => handleButtonChange(button.id, e.target.value)} placeholder="Texto do Botão" className='flex-grow'/> <Handle type="source" position={Position.Right} id={button.id} style={{ top: `${(index + 0.5) * 28}px`, right: '-10px' }} className='!bg-teal-500 !h-2 !w-2 node-handle-glow' isConnectable={true}/> <Button onClick={() => removeButton(button.id)} variant="ghost" size="icon" className={cn(baseButtonSelectStyle, 'ml-1 flex-shrink-0 w-4 h-4 opacity-50 hover:opacity-100 !text-red-500 hover:!bg-red-500/20 rounded-sm')}><X className='w-3 h-3'/></Button> </div> ))} </div> <NodeButton onClick={addButton}><Plus className="mr-1 h-3 w-3"/> Adicionar Botão</NodeButton> </CardContent> </Card> ); }
function ImageNode({ id, data }: NodeProps<ImageData>) { const { setNodes } = useReactFlow(); const [url, setUrl] = useState(data?.url || ''); const [caption, setCaption] = useState(data?.caption || ''); const captionAreaRef = useRef<HTMLTextAreaElement>(null); const updateNodeData = (newData: Partial<ImageData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }
const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => { setUrl(e.target.value); updateNodeData({ url: e.target.value }); }; const handleCaptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setCaption(e.target.value); updateNodeData({ caption: e.target.value }); if (captionAreaRef.current) { captionAreaRef.current.style.height = 'auto'; captionAreaRef.current.style.height = `${captionAreaRef.current.scrollHeight}px`; }}; useEffect(() => { if (captionAreaRef.current) { captionAreaRef.current.style.height = 'auto'; captionAreaRef.current.style.height = `${captionAreaRef.current.scrollHeight}px`; }}, []); return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={ImageIcon} /> Imagem</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>URL da Imagem</NodeLabel> <NodeInput value={url} onChange={handleUrlChange} placeholder="https://..." /> <NodeLabel>Legenda (Opcional)</NodeLabel> <NodeTextarea ref={captionAreaRef} value={caption} onChange={handleCaptionChange} placeholder="Legenda..." /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function DelayNode({ id, data }: NodeProps<DelayData>) { const { setNodes } = useReactFlow(); const [duration, setDuration] = useState(data?.duration || 1); const [unit, setUnit] = useState<'seconds' | 'minutes'>(data?.unit || 'seconds'); const updateNodeData = (newData: Partial<DelayData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }
const handleDurationChange = (e: React.ChangeEvent<HTMLInputElement>) => { const val = parseInt(e.target.value) || 1; setDuration(val); updateNodeData({ duration: val }); }; const handleUnitChange = (value: 'seconds' | 'minutes') => { setUnit(value); updateNodeData({ unit: value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-40")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Clock} /> Atraso</div></CardHeader> <CardContent className="p-2 flex items-center space-x-1"> <NodeInput type="number" value={duration} onChange={handleDurationChange} className="w-16" min={1}/> <NodeSelect value={unit} onValueChange={handleUnitChange}> <SelectItem value="seconds" className='text-xs'>Segundos</SelectItem> <SelectItem value="minutes" className='text-xs'>Minutos</SelectItem> </NodeSelect> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function ListMessageNode({ id, data }: NodeProps<ListMessageData>) { const { setNodes } = useReactFlow(); const [buttonText, setButtonText] = useState(data?.buttonText || 'Opções'); const [title, setTitle] = useState(data?.title || 'Título da Lista'); const [body, setBody] = useState(data?.text || ''); const [footer, setFooter] = useState(data?.footer || ''); const [sections, setSections] = useState<ListSection[]>(data?.sections || [{id:`sec_${Date.now()}`, title:'Seção 1', rows:[{id:`row_${Date.now()}`, title:'Item 1'}]}]); const updateNodeData = (newData: Partial<ListMessageData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }
return ( <Card className={cn(baseCardStyle, "node-card w-64")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={ListChecks} className="text-cyan-400"/> Lista</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Texto Botão</NodeLabel> <NodeInput value={buttonText} onChange={(e) => { setButtonText(e.target.value); updateNodeData({ buttonText: e.target.value }); }} placeholder="Texto do Botão..." /> <NodeLabel>Título Lista</NodeLabel> <NodeInput value={title} onChange={(e) => { setTitle(e.target.value); updateNodeData({ title: e.target.value }); }} placeholder="Título..." /> <NodeLabel>Corpo (Opcional)</NodeLabel> <NodeTextarea value={body} onChange={(e) => { setBody(e.target.value); updateNodeData({ text: e.target.value }); }} placeholder="Descrição da lista..." /> <NodeLabel>Rodapé (Opcional)</NodeLabel> <NodeTextarea value={footer} onChange={(e) => { setFooter(e.target.value); updateNodeData({ footer: e.target.value }); }} placeholder="Texto rodapé..." /> <NodeLabel>Seções/Itens (Simplificado)</NodeLabel> <div className={cn(baseInputInsetStyle, 'text-[9px] text-gray-400 p-1 min-h-[20px] max-h-20 overflow-y-auto custom-scrollbar rounded-sm')}> {sections.map((s, sIdx) => ( <div key={s.id}> <strong className='text-[10px] text-gray-300'>{s.title || `Seção ${sIdx + 1}`}</strong>: {s.rows.map(r => r.title || 'Item').join(', ')} </div> ))} </div> </CardContent> {sections.flatMap((section, sIdx) => section.rows.map((row, rIdx) => ( <Handle key={row.id} type="source" position={Position.Right} id={row.id} style={{ top: `${40 + sIdx * 20 + rIdx * 10}%`, right: '-10px' }} className='!bg-cyan-500 !h-2 !w-2 node-handle-glow' title={row.title || `Item ${rIdx + 1}`} isConnectable={true} /> )))} <Handle type="source" position={Position.Bottom} id="source-fallback" style={{ bottom: '-10px', left: '50%' }} className='!bg-orange-500 !h-2 !w-2 node-handle-glow' title="Fallback (Sem seleção)" isConnectable={true}/> </Card> ); }
function WaitInputNode({ id, data }: NodeProps<WaitInputData>) { const { setNodes } = useReactFlow(); const [variableName, setVariableName] = useState(data?.variableName || 'userInput'); const [message, setMessage] = useState(data?.message || ''); const [timeoutSeconds, setTimeoutSeconds] = useState<number | undefined>(data?.timeoutSeconds); const textAreaRef = useRef<HTMLTextAreaElement>(null); const updateNodeData = (newData: Partial<WaitInputData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }
const handleVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setVariableName(e.target.value); updateNodeData({ variableName: e.target.value }); }; const handleMsgChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setMessage(e.target.value); updateNodeData({ message: e.target.value }); if (textAreaRef.current) { textAreaRef.current.style.height = 'auto'; textAreaRef.current.style.height = `${textAreaRef.current.scrollHeight}px`; }}; const handleTimeoutChange = (e: React.ChangeEvent<HTMLInputElement>) => { const val = e.target.value ? parseInt(e.target.value, 10) : undefined; setTimeoutSeconds(val); updateNodeData({ timeoutSeconds: val }); }; useEffect(() => { if (textAreaRef.current) { textAreaRef.current.style.height = 'auto'; textAreaRef.current.style.height = `${textAreaRef.current.scrollHeight}px`; }}, []); return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={HelpCircle} /> Esperar Input</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Salvar em Variável</NodeLabel> <NodeInput value={variableName} onChange={handleVarChange} placeholder="nome_variavel" /> <NodeLabel>Mensagem (Opcional)</NodeLabel> <NodeTextarea ref={textAreaRef} value={message} onChange={handleMsgChange} placeholder="Ex: Digite seu nome..." /> <NodeLabel>Timeout (Segundos, Opcional)</NodeLabel> <NodeInput type="number" value={timeoutSeconds ?? ''} onChange={handleTimeoutChange} placeholder="Ex: 60" min={1} /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-received" title="Recebido" isConnectable={true} className="!bg-gray-600"/> <Handle type="source" position={Position.Right} id="source-timeout" style={{ top: '65%', right: '-10px' }} className='!bg-orange-500 !h-2 !w-2 node-handle-glow' title="Timeout" isConnectable={!!timeoutSeconds}/> </Card> ); }
function SetVariableNode({ id, data }: NodeProps<SetVariableData>) { const { setNodes } = useReactFlow(); const [variableName, setVariableName] = useState(data?.variableName || 'myVar'); const [value, setValue] = useState(data?.value || ''); const updateNodeData = (newData: Partial<SetVariableData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }
const handleVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setVariableName(e.target.value); updateNodeData({ variableName: e.target.value }); }; const handleValueChange = (e: React.ChangeEvent<HTMLInputElement>) => { setValue(e.target.value); updateNodeData({ value: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Variable} /> Definir Variável</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Nome da Variável</NodeLabel> <NodeInput value={variableName} onChange={handleVarChange} placeholder="nome_variavel" /> <NodeLabel>Valor (Use {'{{var}}'} para outras vars)</NodeLabel> <NodeInput value={value} onChange={handleValueChange} placeholder={'Valor ou {{outra_var}}'} /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }
function ConditionNode({ id, data }: NodeProps<ConditionData>) { const { setNodes } = useReactFlow(); const [variableName, setVariableName] = useState(data?.variableName || ''); const [comparison, setComparison] = useState<ConditionData['comparison']>(data?.comparison || 'equals'); const [value, setValue] = useState(data?.value || ''); const showValueInput = !['isSet', 'isNotSet'].includes(comparison); const updateNodeData = (newData: Partial<ConditionData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setVariableName(e.target.value); updateNodeData({ variableName: e.target.value }); }; const handleCompChange = (val: ConditionData['comparison']) => { setComparison(val); updateNodeData({ comparison: val, value: ['isSet', 'isNotSet'].includes(val) ? '' : value }); }; const handleValueChange = (e: React.ChangeEvent<HTMLInputElement>) => { setValue(e.target.value); updateNodeData({ value: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-56")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Waypoints} /> Condição</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Variável</NodeLabel> <NodeInput value={variableName} onChange={handleVarChange} placeholder="nome_variavel" /> <NodeLabel>Comparação</NodeLabel> <NodeSelect value={comparison} onValueChange={handleCompChange}> <SelectItem value="equals" className='text-xs'>Igual a</SelectItem> <SelectItem value="contains" className='text-xs'>Contém</SelectItem> <SelectItem value="startsWith" className='text-xs'>Começa com</SelectItem> <SelectItem value="isSet" className='text-xs'>Está Definida</SelectItem> <SelectItem value="isNotSet" className='text-xs'>Não Definida</SelectItem> <SelectItem value="greaterThan" className='text-xs'>Maior que (Num)</SelectItem> <SelectItem value="lessThan" className='text-xs'>Menor que (Num)</SelectItem> </NodeSelect> {showValueInput && <> <NodeLabel>Valor (Use {'{{var}}'})</NodeLabel> <NodeInput value={value} onChange={handleValueChange} placeholder={'Valor ou {{outra_var}}'} /> </>} </CardContent> <Handle type="source" position={Position.Right} id="source-true" style={{ top: '35%', right: '-10px' }} className='!bg-green-500 !h-2 !w-2 node-handle-glow' title="Verdadeiro" isConnectable={true}/> <Handle type="source" position={Position.Right} id="source-false" style={{ top: '65%', right: '-10px' }} className='!bg-red-500 !h-2 !w-2 node-handle-glow' title="Falso" isConnectable={true}/> </Card> ); }
function ApiCallNode({ id, data }: NodeProps<ApiCallData>) { const { setNodes } = useReactFlow(); const [apiUrl, setApiUrl] = useState(data?.apiUrl || ''); const [method, setMethod] = useState<ApiCallData['method']>(data?.method || 'GET'); const [saveResponseTo, setSaveResponseTo] = useState(data?.saveResponseTo || ''); const updateNodeData = (newData: Partial<ApiCallData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => { setApiUrl(e.target.value); updateNodeData({ apiUrl: e.target.value }); }; const handleMethodChange = (val: ApiCallData['method']) => { setMethod(val); updateNodeData({ method: val }); }; const handleSaveVarChange = (e: React.ChangeEvent<HTMLInputElement>) => { setSaveResponseTo(e.target.value); updateNodeData({ saveResponseTo: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-60")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={RadioTower} /> API Call</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>URL (Use {'{{var}}'})</NodeLabel> <NodeInput value={apiUrl} onChange={handleUrlChange} placeholder="https://api.exemplo.com/..." /> <NodeLabel>Método</NodeLabel> <NodeSelect value={method} onValueChange={handleMethodChange}> <SelectItem value="GET" className='text-xs'>GET</SelectItem> <SelectItem value="POST" className='text-xs'>POST</SelectItem> <SelectItem value="PUT" className='text-xs'>PUT</SelectItem> <SelectItem value="DELETE" className='text-xs'>DELETE</SelectItem> </NodeSelect> <NodeLabel>Salvar Resposta em (Opcional)</NodeLabel> <NodeInput value={saveResponseTo} onChange={handleSaveVarChange} placeholder="nome_variavel_resposta" /> </CardContent> <Handle type="source" position={Position.Bottom} id="source-success" title="Sucesso" isConnectable={true} className="!bg-gray-600"/> <Handle type="source" position={Position.Right} id="source-error" style={{ top: '50%', right: '-10px' }} className='!bg-red-500 !h-2 !w-2 node-handle-glow' title="Erro" isConnectable={true}/> </Card> ); }
function AssignAgentNode({ id, data }: NodeProps<AssignAgentData>) { const { setNodes } = useReactFlow(); const [department, setDepartment] = useState(data?.department || ''); const [message, setMessage] = useState(data?.message || ''); const textAreaRef = useRef<HTMLTextAreaElement>(null); const updateNodeData = (newData: Partial<AssignAgentData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleDeptChange = (e: React.ChangeEvent<HTMLInputElement>) => { setDepartment(e.target.value); updateNodeData({ department: e.target.value }); }; const handleMsgChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { setMessage(e.target.value); updateNodeData({ message: e.target.value }); if (textAreaRef.current) { textAreaRef.current.style.height = 'auto'; textAreaRef.current.style.height = `${textAreaRef.current.scrollHeight}px`; }}; useEffect(() => { if (textAreaRef.current) { textAreaRef.current.style.height = 'auto'; textAreaRef.current.style.height = `${textAreaRef.current.scrollHeight}px`; }}, []); return ( <Card className={cn(baseCardStyle, "node-card w-52")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={UserCheck} /> Atribuir Agente</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Departamento (Opcional)</NodeLabel> <NodeInput value={department} onChange={handleDeptChange} placeholder="Ex: Vendas" /> <NodeLabel>Mensagem Inicial (Opcional)</NodeLabel> <NodeTextarea ref={textAreaRef} value={message} onChange={handleMsgChange} placeholder="Mensagem para o agente..." /> </CardContent> </Card> ); }
function EndFlowNode({ id, data }: NodeProps<EndFlowData>) { const { setNodes } = useReactFlow(); const [reason, setReason] = useState(data?.reason || ''); const updateNodeData = (newData: Partial<EndFlowData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleReasonChange = (e: React.ChangeEvent<HTMLInputElement>) => { setReason(e.target.value); updateNodeData({ reason: e.target.value }); }; return ( <Card className={cn(baseCardStyle, "node-card w-40")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={LogOut} className="text-red-500" /> Encerrar</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Motivo (Opcional)</NodeLabel> <NodeInput value={reason} onChange={handleReasonChange} placeholder="Motivo do fim"/> </CardContent> </Card> ); }
function GoToFlowNode({ id, data }: NodeProps<GoToFlowData>) { const { setNodes } = useReactFlow(); const [targetFlowId, setTargetFlowId] = useState(data?.targetFlowId || ''); const updateNodeData = (newData: Partial<GoToFlowData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleIdChange = (e: React.ChangeEvent<HTMLInputElement>) => { setTargetFlowId(e.target.value); updateNodeData({ targetFlowId: e.target.value }); }
return ( <Card className={cn(baseCardStyle, "node-card w-48")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Workflow} /> Ir p/ Fluxo</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>ID do Fluxo de Destino</NodeLabel> <NodeInput value={targetFlowId} onChange={handleIdChange} placeholder="ID numérico" /> </CardContent> </Card> ); }
function TagContactNode({ id, data }: NodeProps<TagContactData>) { const { setNodes } = useReactFlow(); const [tagName, setTagName] = useState(data?.tagName || ''); const [action, setAction] = useState<'add' | 'remove'>(data?.action || 'add'); const updateNodeData = (newData: Partial<TagContactData>) => { setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, ...newData } } : n)); }; const handleTagChange = (e: React.ChangeEvent<HTMLInputElement>) => { setTagName(e.target.value); updateNodeData({ tagName: e.target.value }); }; const handleActionChange = (val: 'add' | 'remove') => { setAction(val); updateNodeData({ action: val }); }; return ( <Card className={cn(baseCardStyle, "node-card w-48")}> <Handle type="target" position={Position.Top} id="target-top" isConnectable={true} className="!bg-gray-600"/> <CardHeader className="node-header"><div className="node-header-icon-title"><IconWithGlow icon={Target} /> Tag Contato</div></CardHeader> <CardContent className="p-2 space-y-1"> <NodeLabel>Nome da Tag</NodeLabel> <NodeInput value={tagName} onChange={handleTagChange} placeholder="Ex: Lead Qualificado" /> <NodeLabel>Ação</NodeLabel> <NodeSelect value={action} onValueChange={handleActionChange}> <SelectItem value="add" className='text-xs'>Adicionar Tag</SelectItem> <SelectItem value="remove" className='text-xs'>Remover Tag</SelectItem> </NodeSelect> </CardContent> <Handle type="source" position={Position.Bottom} id="source-bottom" isConnectable={true} className="!bg-gray-600"/> </Card> ); }

// --- Menu Contexto ---
interface ContextMenuData { id: string; top: number; left: number; nodeType: string | undefined; }
const NodeContextMenu = ({ id, top, left, nodeType, onClose, onDelete, onDuplicate }: { id: string; top: number; left: number; nodeType: string | undefined; onClose: () => void; onDelete: (id: string) => void; onDuplicate: (id: string) => void }) => { const style = { top: `${top}px`, left: `${left}px`, }; return ( <div style={style} className={cn(popoverContentStyle, "absolute z-50 w-40 rounded-md p-1 shadow-lg")}> <button onClick={() => onDuplicate(id)} className={cn(baseButtonSelectStyle, "context-menu-button w-full text-left px-2 py-1 text-xs rounded hover:!bg-[${NEON_COLOR}]/30")}> <IconCopy className="context-menu-icon h-3 w-3 mr-1.5 inline-block align-middle" style={{ filter: `drop-shadow(0 0 2px ${NEON_COLOR}99)` }} /> Duplicar Nó </button> <button onClick={() => onDelete(id)} className={cn(baseButtonSelectStyle, "context-menu-button w-full text-left px-2 py-1 text-xs rounded mt-1 !text-red-400 hover:!bg-red-500/30")}> <IconTrash className="context-menu-icon h-3 w-3 mr-1.5 inline-block align-middle" style={{ filter: `drop-shadow(0 0 2px #ef444499)` }} /> Deletar Nó </button> </div> ); };

// --- Componente Principal Interno ---
function WhatsAppFlowEditor() {
    const [nodes, setNodes, onNodesChange] = useNodesState([]);
    const [edges, setEdges, onEdgesChange] = useEdgesState([]);
    const reactFlowInstance = useReactFlow<any, any>();
    const { toast } = useToast();
    const [flowsList, setFlowsList] = useState<FlowData[]>([]);
    const [campaignList, setCampaignList] = useState<CampaignSelectItem[]>([]);
    const [selectedFlow, setSelectedFlow] = useState<FlowData | null>(null);
    const [flowNameInput, setFlowNameInput] = useState('');
    const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null);
    const [filterCampaignId, setFilterCampaignId] = useState<string | 'all'>('all');
    const [activeTab, setActiveTab] = useState("dashboard");
    const [isConnected, setIsConnected] = useState(false);
    const [qrCode, setQrCode] = useState<string | null>(null);
    const [isConnecting, setIsConnecting] = useState(false);
    const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false);
    const reactFlowWrapper = useRef<HTMLDivElement>(null);
    const [contextMenu, setContextMenu] = useState<ContextMenuData | null>(null);
    const [isLoadingFlowList, setIsLoadingFlowList] = useState(true);
    const [isLoadingFlowDetails, setIsLoadingFlowDetails] = useState(false);
    const [isSaving, setIsSaving] = useState(false);
    const [isDeleting, setIsDeleting] = useState(false);
    const [isTogglingStatus, setIsTogglingStatus] = useState(false);
    const [initialFlowLoaded, setInitialFlowLoaded] = useState(false);
    const [isSavingSettings, setIsSavingSettings] = useState(false);
    const [settings, setSettings] = useState<AppSettings>({ defaultMessageDelayMs: 500, unknownMessageResponse: 'ignore', defaultReplyMessage: 'Desculpe, não entendi.', adminForwardNumber: '', defaultInputTimeoutSeconds: 60, enableBusinessHours: false, businessHoursStart: '09:00', businessHoursEnd: '18:00', outsideHoursMessage: 'Atendimento fora do horário.', });
    const [contacts, setContacts] = useState<Contact[]>([]);
    const [isLoadingContacts, setIsLoadingContacts] = useState(false);
    const [hasAttemptedContactFetch, setHasAttemptedContactFetch] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [contactFetchTimeoutId, setContactFetchTimeoutId] = useState<NodeJS.Timeout | null>(null);

    const nodeTypes = useMemo(() => ({ textMessage: TextMessageNode, buttonMessage: ButtonMessageNode, imageMessage: ImageNode, delay: DelayNode, listMessage: ListMessageNode, waitInput: WaitInputNode, setVariable: SetVariableNode, condition: ConditionNode, apiCall: ApiCallNode, assignAgent: AssignAgentNode, endFlow: EndFlowNode, goToFlow: GoToFlowNode, tagContact: TagContactNode }), []);

    // --- Funções de Lógica ---
    const checkConnectionStatus = useCallback(async () => { try { const response = await fetch('/api/whatsapp/status'); if (!response.ok) throw new Error('Falha status'); const data = await response.json(); setIsConnected(data.status === 'connected'); setQrCode(data.qrCodeString || null); setIsConnecting(data.status === 'connecting'); } catch (error) { console.error("Erro status WPP:", error); setIsConnected(false); setQrCode(null); setIsConnecting(false); } }, []);
    useEffect(() => { checkConnectionStatus(); const intervalId = setInterval(checkConnectionStatus, 7000); return () => clearInterval(intervalId); }, [checkConnectionStatus]);
    const connectWhatsApp = useCallback(async () => { if (isConnecting || isConnected) return; toast({ title: "Iniciando conexão..." }); setIsConnecting(true); setQrCode(null); try { const response = await fetch('/api/whatsapp/connect', { method: 'POST' }); if (!response.ok) { let errMsg = 'Falha conexão'; try { const err = await response.json(); errMsg = err.message || errMsg; } catch(e){} throw new Error(errMsg); } toast({ title: "Solicitação enviada!" }); } catch (error: any) { toast({ title: "Erro Conexão", description: error.message, variant: "destructive" }); setIsConnecting(false); } }, [toast, isConnecting, isConnected]);
    const disconnectWhatsApp = useCallback(async () => { if (!isConnected) return; toast({ title: "Desconectando..." }); setIsConnecting(true); try { const response = await fetch('/api/whatsapp/disconnect', { method: 'POST' }); if (!response.ok) { let errMsg = 'Falha desconexão'; try { const err = await response.json(); errMsg = err.message || errMsg; } catch(e){} throw new Error(errMsg); } toast({ title: "WhatsApp Desconectado" }); setContacts([]); setHasAttemptedContactFetch(false); } catch (error: any) { toast({ title: "Erro Desconexão", description: error.message, variant: "destructive" }); } finally { setIsConnecting(false); } }, [toast, isConnected]);
    const fetchCampaigns = useCallback(async () => { try { const response = await fetch('/api/campaigns'); if (!response.ok) throw new Error('Falha'); const data: CampaignSelectItem[] = await response.json(); setCampaignList(data); } catch (error: any) { toast({ title: "Erro Campanhas", description: error.message, variant: "destructive" }); setCampaignList([]); } }, [toast]);
    const loadFlow = useCallback(async (flowId: number | string | null) => { if (!flowId || isLoadingFlowDetails || (typeof flowId === 'string' && isNaN(parseInt(flowId)))) { if (!flowId && selectedFlow !== null) { setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); } return; } const idNum = typeof flowId === 'string' ? parseInt(flowId) : flowId; if(selectedFlow?.id === idNum && nodes.length > 0 && initialFlowLoaded) { return; } setIsLoadingFlowDetails(true); setContextMenu(null); try { const response = await fetch(`/api/flows?id=${idNum}`); if (!response.ok) { if (response.status === 404) { toast({ title: "Aviso", description: `Fluxo ID ${idNum} não encontrado.`, variant: "default" }); setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); } else { const err = await response.json(); throw new Error(err.message || `Falha (status ${response.status})`); } return; } const flow: FlowData = await response.json(); setSelectedFlow(flow); setFlowNameInput(flow.name); setSelectedCampaignId(flow.campaign_id ?? null); const flowElements = flow.elements || { nodes: [], edges: [] }; const nodesArray = Array.isArray(flowElements.nodes) ? flowElements.nodes : []; const edgesArray = Array.isArray(flowElements.edges) ? flowElements.edges : []; const nodesWithHandle = nodesArray.map(n => ({ ...n, dragHandle: '.node-header' })); setNodes(nodesWithHandle); setEdges(edgesArray); setInitialFlowLoaded(true); if (reactFlowInstance) { setTimeout(() => { try { reactFlowInstance.fitView({ duration: 400, padding: 0.2 }); } catch(e) { console.error("[loadFlow] Erro fitView:", e); } }, 100); } } catch (error: any) { console.error(`[loadFlow] Erro ID ${idNum}:`, error); toast({ title: "Erro ao Carregar Fluxo", description: error.message, variant: "destructive" }); setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); if(reactFlowInstance) setTimeout(() => reactFlowInstance.fitView({duration: 200}), 50); } finally { setIsLoadingFlowDetails(false); } }, [ setNodes, setEdges, toast, isLoadingFlowDetails, reactFlowInstance, selectedFlow?.id, nodes.length, initialFlowLoaded]);
    const fetchFlows = useCallback(async (selectInitial = false) => { setIsLoadingFlowList(true); setContextMenu(null); let firstFlowIdToLoad: number | string | null = null; try { const url = filterCampaignId === 'all' ? '/api/flows' : filterCampaignId === 'none' ? '/api/flows?campaignId=null' : `/api/flows?campaignId=${filterCampaignId}`; const response = await fetch(url); if (!response.ok) { const err = await response.json(); throw new Error(err.message || 'Falha'); } const data: FlowData[] = await response.json(); setFlowsList(data); const currentSelectedExistsInNewList = data.some(f => f.id === selectedFlow?.id); if (data.length === 0) { if (selectedFlow !== null) { setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); setInitialFlowLoaded(false); } } else if (selectedFlow && !currentSelectedExistsInNewList) { setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); setInitialFlowLoaded(false); if (selectInitial) { firstFlowIdToLoad = data.find(f => f.status === 'active')?.id || data[0].id; } } else if (!selectedFlow && selectInitial && !initialFlowLoaded) { firstFlowIdToLoad = data.find(f => f.status === 'active')?.id || data[0].id; } else if (selectedFlow && currentSelectedExistsInNewList) { const updatedData = data.find(f => f.id === selectedFlow.id); if (updatedData && (updatedData.name !== selectedFlow.name || updatedData.campaign_id !== selectedFlow.campaign_id || updatedData.status !== selectedFlow.status)) { setSelectedFlow(prev => prev ? { ...prev, ...updatedData, elements: prev.elements } : null); setFlowNameInput(updatedData.name); setSelectedCampaignId(updatedData.campaign_id ?? null); } } if (firstFlowIdToLoad) { await loadFlow(firstFlowIdToLoad); } } catch (error: any) { console.error("[fetchFlows] Erro:", error); toast({ title: "Erro Lista Fluxos", description: error.message, variant: "destructive" }); setFlowsList([]); setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); setInitialFlowLoaded(false); if(reactFlowInstance) setTimeout(() => reactFlowInstance.fitView({duration: 200}), 50); } finally { setIsLoadingFlowList(false); } }, [filterCampaignId, selectedFlow, reactFlowInstance, toast, loadFlow, setNodes, setEdges, initialFlowLoaded]);
    useEffect(() => { fetchCampaigns(); }, [fetchCampaigns]);
    useEffect(() => { fetchFlows(true); }, [filterCampaignId]);
    const saveFlow = useCallback(async () => { if (!selectedFlow || isSaving || !flowNameInput.trim() || !reactFlowInstance) return; setIsSaving(true); try { const currentNodes = reactFlowInstance.getNodes(); const currentEdges = reactFlowInstance.getEdges(); const nodesToSave = currentNodes.map(({ dragHandle, ...node }) => node); const flowToSave = { name: flowNameInput.trim(), campaign_id: selectedCampaignId || null, status: selectedFlow.status || 'draft', elements: { nodes: nodesToSave, edges: currentEdges } }; const response = await fetch(`/api/flows?id=${selectedFlow.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(flowToSave) }); if (!response.ok) { const err = await response.json(); throw new Error(err.message || 'Falha'); } toast({ title: "Fluxo Salvo!" }); setSelectedFlow(prev => prev ? { ...prev, name: flowToSave.name, campaign_id: flowToSave.campaign_id, status: flowToSave.status, updated_at: new Date().toISOString() } : null); setFlowsList(prev => prev.map(f => f.id === selectedFlow.id ? { ...f, name: flowToSave.name, campaign_id: flowToSave.campaign_id, status: flowToSave.status, updated_at: new Date().toISOString() } : f)); } catch (error: any) { toast({ title: "Erro ao Salvar", description: error.message, variant: "destructive" }); } finally { setIsSaving(false); } }, [selectedFlow, flowNameInput, selectedCampaignId, reactFlowInstance, toast, isSaving]);
    const createNewFlow = useCallback(async () => { if (isLoadingFlowList || isLoadingFlowDetails || isSaving) return; const newFlowName = prompt("Nome:", "Novo Fluxo"); if (!newFlowName || !newFlowName.trim()) return; setIsLoadingFlowDetails(true); try { const campaignIdToSend = filterCampaignId === 'all' || filterCampaignId === 'none' ? null : filterCampaignId; const response = await fetch('/api/flows', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name: newFlowName.trim(), campaign_id: campaignIdToSend }) }); if (!response.ok) { const err = await response.json(); throw new Error(err.message || 'Falha'); } const createdFlow: FlowData = await response.json(); toast({ title: "Fluxo Criado!" }); setInitialFlowLoaded(false); await fetchFlows(false); await loadFlow(createdFlow.id); setActiveTab('flows'); } catch (error: any) { toast({ title: "Erro ao Criar", description: error.message, variant: "destructive" }); } finally { setIsLoadingFlowDetails(false); } }, [toast, filterCampaignId, fetchFlows, loadFlow, isLoadingFlowList, isLoadingFlowDetails, isSaving]);
    const deleteSelectedFlow = useCallback(async () => { if (!selectedFlow || isDeleting || isLoadingFlowList || isLoadingFlowDetails || isSaving) return; if (!confirm(`Deletar "${selectedFlow.name}"?`)) return; setIsDeleting(true); try { const response = await fetch(`/api/flows?id=${selectedFlow.id}`, { method: 'DELETE' }); if (!response.ok) { const err = await response.json(); throw new Error(err.message || 'Falha'); } toast({ title: "Fluxo Deletado" }); setSelectedFlow(null); setNodes([]); setEdges([]); setFlowNameInput(''); setSelectedCampaignId(null); setInitialFlowLoaded(false); await fetchFlows(true); } catch (error: any) { toast({ title: "Erro ao Deletar", description: error.message, variant: "destructive" }); } finally { setIsDeleting(false); } }, [selectedFlow, toast, fetchFlows, setNodes, setEdges, isDeleting, isLoadingFlowList, isLoadingFlowDetails, isSaving]);
    const toggleFlowStatus = useCallback(async () => { if (!selectedFlow || isTogglingStatus || isLoadingFlowList || isLoadingFlowDetails || isSaving) return; setIsTogglingStatus(true); const newStatus = selectedFlow.status === 'active' ? 'inactive' : 'active'; try { const response = await fetch(`/api/flows?id=${selectedFlow.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ status: newStatus }) }); if (!response.ok) { const err = await response.json(); throw new Error(err.message || 'Falha'); } toast({ title: `Fluxo ${newStatus === 'active' ? 'Ativado' : 'Desativado'}` }); setSelectedFlow(prev => prev ? { ...prev, status: newStatus, updated_at: new Date().toISOString() } : null); setFlowsList(prev => prev.map(f => f.id === selectedFlow.id ? { ...f, status: newStatus, updated_at: new Date().toISOString() } : (newStatus === 'active' ? {...f, status: 'inactive'} : f) )); if (newStatus === 'active') { fetch('/api/whatsapp/reload-flow', { method: 'POST' }).catch(err => console.error("Erro ao solicitar reload-flow:", err)); } } catch (error: any) { toast({ title: "Erro Status", description: error.message, variant: "destructive" }); } finally { setIsTogglingStatus(false); } }, [selectedFlow, toast, isTogglingStatus, isLoadingFlowList, isLoadingFlowDetails, isSaving]);
    const onConnect: OnConnect = useCallback((connection) => { const sourceHandleId = connection.sourceHandle || 'source-bottom'; const isMultipleOutputHandle = sourceHandleId.startsWith('btn_') || sourceHandleId.startsWith('list-item-'); const isStandardOutputHandle = ['source-bottom', 'source-success', 'source-received', 'source-timeout', 'source-true', 'source-false', 'source-error', 'source-fallback'].includes(sourceHandleId); if (!isMultipleOutputHandle && isStandardOutputHandle) { const existingEdge = edges.find(e => e.source === connection.source && e.sourceHandle === sourceHandleId); if (existingEdge) { setEdges((eds) => addEdge({ ...connection, markerEnd: { type: MarkerType.ArrowClosed, color: NEON_COLOR } }, eds.filter(e => !(e.source === connection.source && e.sourceHandle === sourceHandleId)))); return; } } setEdges((eds) => addEdge({ ...connection, markerEnd: { type: MarkerType.ArrowClosed, color: NEON_COLOR }, style: { stroke: NEON_COLOR, strokeWidth: 1.5 } }, eds)); }, [setEdges, edges]);
    const toggleSidebar = useCallback(() => setIsSidebarCollapsed(prev => !prev), []);
    const handleNodeContextMenu = useCallback((event: React.MouseEvent, node: Node) => { event.preventDefault(); if (isLoadingFlowDetails || isSaving) return; const reactFlowBounds = reactFlowWrapper.current?.getBoundingClientRect(); if (reactFlowBounds) { setContextMenu({ id: node.id, top: event.clientY - reactFlowBounds.top, left: event.clientX - reactFlowBounds.left, nodeType: node.type, }); } }, [isLoadingFlowDetails, isSaving]);
    const handlePaneClick = useCallback(() => setContextMenu(null), []);
    const handleDeleteNode = useCallback((nodeId: string) => { if (isLoadingFlowDetails || isSaving) return; setNodes((nds) => nds.filter((node) => node.id !== nodeId)); setEdges((eds) => eds.filter((edge) => edge.source !== nodeId && edge.target !== nodeId)); setContextMenu(null); }, [setNodes, setEdges, isLoadingFlowDetails, isSaving]);
    const handleDuplicateNode = useCallback((nodeId: string) => { if (isLoadingFlowDetails || isSaving || !reactFlowInstance) return; const nodeToDuplicate = reactFlowInstance.getNode(nodeId); if (!nodeToDuplicate) return; const newNodeId = `node_${nodeToDuplicate.type}_${Date.now()}_${Math.random().toString(16).substring(2, 8)}`; const position = { x: nodeToDuplicate.position.x + 30, y: nodeToDuplicate.position.y + 30 }; let newData = JSON.parse(JSON.stringify(nodeToDuplicate.data)); if (nodeToDuplicate.type === 'buttonMessage' && newData.buttons) { newData.buttons = newData.buttons.map((btn: ButtonOption) => ({ ...btn, id: `btn_${Date.now()}_${Math.random().toString(16).substring(2, 6)}` })); } if (nodeToDuplicate.type === 'listMessage' && newData.sections) { newData.sections = newData.sections.map((sec: ListSection) => ({ ...sec, id: `sec_${Date.now()}_${Math.random().toString(16).substring(2, 6)}`, rows: sec.rows.map((row: ListItem) => ({ ...row, id: `row_${Date.now()}_${Math.random().toString(16).substring(2, 6)}` })) })); } const newNode: Node = { ...nodeToDuplicate, id: newNodeId, position, data: newData, dragHandle: '.node-header' }; reactFlowInstance.addNodes(newNode); setContextMenu(null); }, [reactFlowInstance, isLoadingFlowDetails, isSaving]);
    const addNode = useCallback((type: keyof typeof nodeTypes) => { if (!reactFlowInstance || isLoadingFlowDetails || isSaving || !selectedFlow) return; const reactFlowBounds = reactFlowWrapper.current?.getBoundingClientRect(); const pane = reactFlowWrapper.current?.querySelector('.react-flow__pane'); if (!reactFlowBounds || !pane) return; const { x: viewX, y: viewY, zoom } = reactFlowInstance.getViewport(); const paneRect = pane.getBoundingClientRect(); const centerX = (paneRect.width / 2 - viewX) / zoom; const centerY = (paneRect.height / 2 - viewY) / zoom; const position = { x: centerX, y: centerY }; const newNodeId = `node_${type}_${Date.now()}_${Math.random().toString(16).substring(2, 8)}`; let newNodeData: any = {}; switch (type) { case 'textMessage': newNodeData = { text: '' }; break; case 'buttonMessage': newNodeData = { text: '', buttons: [{ id: `btn_${Date.now()}`, text: 'Opção 1' }] }; break; case 'imageMessage': newNodeData = { url: '' }; break; case 'delay': newNodeData = { duration: 1, unit: 'seconds' }; break; case 'listMessage': newNodeData = { buttonText: 'Opções', title: 'Título', text: 'Escolha:', sections: [{ id: `sec_${Date.now()}`, title: 'Seção 1', rows: [{ id: `row_${Date.now()}`, title: 'Item 1' }] }] }; break; case 'waitInput': newNodeData = { variableName: 'userInput', message: '', timeoutSeconds: settings.defaultInputTimeoutSeconds }; break; case 'setVariable': newNodeData = { variableName: 'myVar', value: '' }; break; case 'condition': newNodeData = { variableName: '', comparison: 'equals', value: '' }; break; case 'apiCall': newNodeData = { apiUrl: '', method: 'GET', saveResponseTo: '' }; break; case 'assignAgent': newNodeData = { department: '', message: '' }; break; case 'endFlow': newNodeData = {}; break; case 'goToFlow': newNodeData = { targetFlowId: '' }; break; case 'tagContact': newNodeData = { tagName: '', action: 'add' }; break; default: break; } const nodeToAdd: Node = { id: newNodeId, type, position, data: newNodeData, dragHandle: '.node-header' }; reactFlowInstance.addNodes(nodeToAdd); setTimeout(() => { reactFlowInstance.setCenter(position.x, position.y, { zoom: reactFlowInstance.getZoom(), duration: 300 }); }, 50); }, [reactFlowInstance, isLoadingFlowDetails, isSaving, nodeTypes, selectedFlow, settings.defaultInputTimeoutSeconds]);
    const dashboardStatsValues = useMemo(() => { const activeFlow = flowsList.find(f => f.status === 'active'); return { activeFlowName: activeFlow?.name || 'Nenhum', totalFlows: flowsList.length, activeConversations: Math.floor(Math.random() * 5), messagesSent: Math.floor(Math.random() * 100), }; }, [flowsList]);
    const handleSettingChange = useCallback((key: keyof AppSettings, value: any) => { setSettings(prev => ({ ...prev, [key]: value })); }, []);
    const saveSettings = useCallback(async () => { setIsSavingSettings(true); console.log("Salvando configurações:", settings); await new Promise(resolve => setTimeout(resolve, 1000)); toast({ title: "Configurações Salvas (Simulado)" }); setIsSavingSettings(false); }, [settings, toast]);
    useEffect(() => { console.log("Carregando configurações (simulado)..."); }, []);
    const isLoading = isLoadingFlowList || isLoadingFlowDetails || isSaving || isDeleting || isTogglingStatus;

    const fetchContacts = useCallback(async () => {
        if (contactFetchTimeoutId) { clearTimeout(contactFetchTimeoutId); setContactFetchTimeoutId(null); }
        if (isLoadingContacts || !isConnected) { console.log('[fetchContacts] Abortando: Carregando ou desconectado.'); if (!isConnected) setHasAttemptedContactFetch(false); return; }
        console.log('[fetchContacts] Iniciando busca de contatos...'); setIsLoadingContacts(true); setHasAttemptedContactFetch(true);
        try {
            const response = await fetch('/api/whatsapp/contacts');
            console.log(`[fetchContacts] Resposta da API: ${response.status}`);
            if (!response.ok) { const errData = await response.text(); let errMsg = `Falha ao buscar contatos (Status: ${response.status})`; try { const errJson = JSON.parse(errData); errMsg = errJson.message || errMsg; } catch (e) { errMsg = `${errMsg}: ${errData}`; } console.error(`[fetchContacts] Erro na resposta da API: ${errMsg}`); throw new Error(errMsg); }
            const data: Contact[] = await response.json();
            console.log(`[fetchContacts] Contatos recebidos: ${data.length}`);
            data.sort((a, b) => (a.name || a.notify || a.jid).localeCompare(b.name || b.notify || b.jid));
            setContacts(data);
        } catch (error: any) { console.error("[fetchContacts] Erro ao buscar contatos:", error); toast({ title: "Erro ao Carregar Contatos", description: error.message, variant: "destructive" }); setContacts([]);
        } finally { console.log('[fetchContacts] Finalizando busca.'); setIsLoadingContacts(false); }
    }, [isConnected, isLoadingContacts, toast, contactFetchTimeoutId]);

     useEffect(() => {
        console.log(`[useEffect Contacts] Aba: ${activeTab}, Conectado: ${isConnected}, Carregando: ${isLoadingContacts}, Tentou Buscar: ${hasAttemptedContactFetch}, TimeoutID: ${contactFetchTimeoutId}`);
        if (contactFetchTimeoutId) { clearTimeout(contactFetchTimeoutId); setContactFetchTimeoutId(null); }
        if (activeTab === 'contacts' && isConnected && !isLoadingContacts && !hasAttemptedContactFetch) {
            console.log('[useEffect Contacts] Agendando busca de contatos em 5 segundos...');
            const timeoutId = setTimeout(() => { console.log('[useEffect Contacts] Timeout executado, chamando fetchContacts...'); fetchContacts(); setContactFetchTimeoutId(null); }, 5000);
            setContactFetchTimeoutId(timeoutId);
        }
        if (activeTab !== 'contacts' || !isConnected) { if (hasAttemptedContactFetch || contactFetchTimeoutId) { console.log("[useEffect Contacts] Resetando flag e limpando timeout."); if (contactFetchTimeoutId) clearTimeout(contactFetchTimeoutId); setContactFetchTimeoutId(null); setHasAttemptedContactFetch(false); } }
        return () => { if (contactFetchTimeoutId) { console.log('[useEffect Contacts Cleanup] Limpando timeout pendente.'); clearTimeout(contactFetchTimeoutId); } };
    }, [activeTab, isConnected, isLoadingContacts, hasAttemptedContactFetch, fetchContacts, contactFetchTimeoutId]);

    useEffect(() => { if (!isConnected) { setContacts([]); if (contactFetchTimeoutId) { clearTimeout(contactFetchTimeoutId); setContactFetchTimeoutId(null); } } }, [isConnected, contactFetchTimeoutId]);

    const filteredContacts = useMemo(() => { if (!searchTerm) return contacts; const lowerSearchTerm = searchTerm.toLowerCase(); return contacts.filter(c => (c.name && c.name.toLowerCase().includes(lowerSearchTerm)) || (c.notify && c.notify.toLowerCase().includes(lowerSearchTerm)) || c.jid.includes(lowerSearchTerm)); }, [contacts, searchTerm]);

    // --- Renderização Final ---
    return (
        <TooltipProvider delayDuration={0}>
            <div className="flex h-screen bg-[#1a1a1a]">
                <Sidebar isCollapsed={isSidebarCollapsed} toggleSidebar={toggleSidebar} />
                <main className={`flex-1 transition-all duration-300 ease-in-out ${isSidebarCollapsed ? 'ml-16' : 'ml-60'} p-4 flex flex-col gap-4 overflow-y-auto`}>
                     <div className="flex justify-between items-center flex-shrink-0">
                         <h1 className="text-xl md:text-2xl font-bold text-white" style={{ textShadow: `0 0 6px ${NEON_COLOR}, 0 0 10px ${NEON_COLOR}` }}>
                             Automação WhatsApp
                         </h1>
                         {isConnecting && !qrCode ? ( <Button variant="secondary" size="sm" className={cn(baseButtonSelectStyle, 'opacity-70 cursor-not-allowed h-8 px-3')} disabled> <Activity className='mr-2 h-4 w-4 animate-spin' style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR})` }}/> Conectando... </Button> ) : isConnected ? ( <Button onClick={disconnectWhatsApp} variant="destructive" size="sm" className={cn(baseButtonSelectStyle, 'hover:!bg-red-500/30 !text-red-400 h-8 px-3')} disabled={isConnecting}> <Unplug className='mr-2 h-4 w-4' style={{ filter: `drop-shadow(0 0 4px #ef4444)` }}/> Desconectar </Button> ) : ( <Button onClick={connectWhatsApp} variant="primary" size="sm" className={cn(baseButtonSelectStyle, `hover:!bg-[${NEON_COLOR}]/30 h-8 px-3`)} disabled={isConnecting}> <PlugZap className='mr-2 h-4 w-4' style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR})` }}/> Conectar WhatsApp </Button> )}
                     </div>
                     <Tabs defaultValue="dashboard" value={activeTab} onValueChange={setActiveTab} className="flex-grow flex flex-col space-y-3 min-h-0">
                        <TabsList className={cn("p-1 flex-shrink-0 rounded-lg w-full justify-start", baseInputInsetStyle)}>
                            <TabsTrigger value="dashboard" className={cn("tab-trigger text-xs px-3 py-1.5 rounded", baseButtonSelectStyle, `data-[state=active]:!shadow-[inset_2px_2px_4px_rgba(0,0,0,0.3),inset_-2px_-2px_4px_rgba(255,255,255,0.05)] data-[state=active]:!bg-[${NEON_COLOR}]/20`)} style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}> <BarChart2 className="tab-icon h-3.5 w-3.5 mr-1.5" style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR})` }}/>Dashboard </TabsTrigger>
                            <TabsTrigger value="flows" className={cn("tab-trigger text-xs px-3 py-1.5 rounded", baseButtonSelectStyle, `data-[state=active]:!shadow-[inset_2px_2px_4px_rgba(0,0,0,0.3),inset_-2px_-2px_4px_rgba(255,255,255,0.05)] data-[state=active]:!bg-[${NEON_COLOR}]/20`)} style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}> <Workflow className="tab-icon h-3.5 w-3.5 mr-1.5" style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR})` }}/>Fluxos </TabsTrigger>
                            <TabsTrigger value="contacts" className={cn("tab-trigger text-xs px-3 py-1.5 rounded", baseButtonSelectStyle, `data-[state=active]:!shadow-[inset_2px_2px_4px_rgba(0,0,0,0.3),inset_-2px_-2px_4px_rgba(255,255,255,0.05)] data-[state=active]:!bg-[${NEON_COLOR}]/20`)} style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}> <Users className="tab-icon h-3.5 w-3.5 mr-1.5" style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR})` }}/>Contatos </TabsTrigger>
                            <TabsTrigger value="settings" className={cn("tab-trigger text-xs px-3 py-1.5 rounded", baseButtonSelectStyle, `data-[state=active]:!shadow-[inset_2px_2px_4px_rgba(0,0,0,0.3),inset_-2px_-2px_4px_rgba(255,255,255,0.05)] data-[state=active]:!bg-[${NEON_COLOR}]/20`)} style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}> <Settings className="tab-icon h-3.5 w-3.5 mr-1.5" style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR})` }}/>Config. </TabsTrigger>
                        </TabsList>

                        <TabsContent value="dashboard" className="flex-grow overflow-y-auto space-y-4 pr-1 custom-scrollbar min-h-0">
                             {!isConnected && !isConnecting && !qrCode && ( <Card className={cn(baseCardStyle, "h-40 flex items-center justify-center")}> <p className="text-gray-400 text-center text-sm" style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>WhatsApp Desconectado.<br/>Clique em "Conectar WhatsApp" acima.</p> </Card> )}
                             {isConnecting && !qrCode && !isConnected && ( <Card className={cn(baseCardStyle, "h-40 flex items-center justify-center")}> <Activity className="h-5 w-5 animate-spin mr-2 text-[#1E90FF]" style={{ filter: `drop-shadow(0 0 5px ${NEON_COLOR})` }}/> <p className="text-gray-400 text-sm" style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>Solicitando conexão, aguarde...</p> </Card> )}
                             {qrCode && !isConnected && ( <div className={cn(baseCardStyle, "p-4 flex flex-col items-center justify-center")}> <p className="text-white text-sm mb-2" style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}>Escaneie o QR Code com seu WhatsApp:</p> <div className="bg-white p-2 rounded"> <QRCodeDynamic value={qrCode} size={192} level={"L"} /> </div> <p className="text-xs text-gray-400 mt-2" style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>Aguardando leitura...</p> </div> )}
                            {isConnected && ( <div className='space-y-4'> <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4"> <ElementCard icon={Check} label="Status" value="Conectado" iconColorClass='text-green-500'/> <ElementCard icon={Layers} label="Fluxo Ativo" value={dashboardStatsValues.activeFlowName} /> <ElementCard icon={Users} label="Conversas Ativas" value={dashboardStatsValues.activeConversations.toString()} /> <ElementCard icon={FileText} label="Fluxos Totais" value={dashboardStatsValues.totalFlows.toString()} /> </div> <Card className={cn(baseCardStyle)}> <CardHeader><CardTitle className="text-sm font-medium text-white" style={{ textShadow: `0 0 5px ${NEON_COLOR}` }}>Atividade Recente</CardTitle></CardHeader> <CardContent><p className='text-gray-400 text-xs' style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>Gráficos e logs de atividade aqui...</p></CardContent> </Card> </div> )}
                        </TabsContent>

                        <TabsContent value="flows" className="flex-grow flex flex-row m-0 p-0 border-none rounded-lg overflow-hidden min-h-0">
                             <div className={cn("w-48 p-2 flex-shrink-0 flex flex-col space-y-1.5 border-r overflow-y-auto custom-scrollbar", baseCardStyle, 'rounded-r-none border-r-[#1E90FF]/20')}>
                                <h3 className="text-sm font-semibold text-center text-white border-b border-[#1E90FF]/20 pb-1 mb-1 sticky top-0 z-10" style={{ textShadow: `0 0 5px ${NEON_COLOR}`, background: 'rgba(20, 20, 20, 0.8)', backdropFilter: 'blur(3px)' }}>
                                    Nós
                                </h3>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('textMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={MessageSquare} className="mr-1.5 h-3.5 w-3.5"/> Texto</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('buttonMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={ListChecks} className="mr-1.5 h-3.5 w-3.5"/> Botões</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('listMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={ListChecks} className="mr-1.5 h-3.5 w-3.5 text-cyan-400"/> Lista</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('imageMessage')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={ImageIcon} className="mr-1.5 h-3.5 w-3.5"/> Imagem</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('delay')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Clock} className="mr-1.5 h-3.5 w-3.5"/> Atraso</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('waitInput')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={HelpCircle} className="mr-1.5 h-3.5 w-3.5"/> Esperar Input</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('setVariable')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Variable} className="mr-1.5 h-3.5 w-3.5"/> Definir Var</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('condition')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Waypoints} className="mr-1.5 h-3.5 w-3.5"/> Condição</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('apiCall')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={RadioTower} className="mr-1.5 h-3.5 w-3.5"/> API Call</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('tagContact')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Target} className="mr-1.5 h-3.5 w-3.5"/> Tag Contato</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('goToFlow')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={Workflow} className="mr-1.5 h-3.5 w-3.5"/> Ir p/ Fluxo</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded")} onClick={() => addNode('assignAgent')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={UserCheck} className="mr-1.5 h-3.5 w-3.5"/> Atribuir Agente</Button>
                                <Button className={cn(baseButtonSelectStyle, "node-add-button justify-start text-xs h-7 px-2 rounded !text-red-400 hover:!bg-red-500/30")} onClick={() => addNode('endFlow')} disabled={isLoading || !selectedFlow}><IconWithGlow icon={LogOut} className="mr-1.5 h-3.5 w-3.5"/> Encerrar</Button>
                             </div>
                            <div className="flex-grow flex flex-col bg-[#1a1a1a] min-w-0">
                                <div className={cn("flex items-center justify-between p-2 border-b flex-shrink-0 gap-2", baseCardStyle, 'rounded-b-none border-b-[#1E90FF]/20')}>
                                     <div className='flex items-center gap-1.5'>
                                         <Select value={filterCampaignId} onValueChange={setFilterCampaignId} disabled={isLoading}> <SelectTrigger className={cn(baseButtonSelectStyle, "w-[150px] h-8 px-2 text-xs rounded")}> <Filter className='h-3 w-3 mr-1 text-gray-400' style={{ filter: `drop-shadow(0 0 3px ${NEON_COLOR}50)` }}/> <SelectValue placeholder="Filtrar..." /> </SelectTrigger> <SelectContent className={cn(popoverContentStyle, "text-xs")}> <SelectItem value="all" className="text-xs hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">Todos Fluxos</SelectItem> <SelectItem value="none" className="text-xs text-muted-foreground hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">Sem Campanha</SelectItem> {campaignList.map(c => (<SelectItem key={c.id} value={c.id} className="text-xs hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">{c.name}</SelectItem>))} </SelectContent> </Select>
                                         <Select onValueChange={(v) => loadFlow(v)} value={selectedFlow?.id?.toString() || ''} disabled={flowsList.length === 0 || isLoading}> <SelectTrigger className={cn(baseButtonSelectStyle, "w-[180px] h-8 px-2 text-xs rounded")}> <SelectValue placeholder={isLoadingFlowList ? "Carregando..." : (flowsList.length === 0 ? "Nenhum fluxo" : "Selecione Fluxo...")} /> </SelectTrigger> <SelectContent className={cn(popoverContentStyle)}> {flowsList.map(f => (<SelectItem key={f.id} value={f.id.toString()} className="text-xs flex justify-between items-center hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]"><span>{f.name}</span> {f.status === 'active' && <Badge variant="success" className='ml-2 px-1 py-0 text-[8px] h-4 bg-green-600/80 border-green-400/50'>Ativo</Badge>}</SelectItem>))} </SelectContent> </Select>
                                     </div>
                                     <div className="flex items-center gap-1.5 flex-grow justify-end">
                                         {selectedFlow && !isLoadingFlowDetails && ( <> <Select value={selectedCampaignId || 'none'} onValueChange={(v) => setSelectedCampaignId(v === 'none' ? null : v)} disabled={isLoading}> <SelectTrigger className={cn(baseButtonSelectStyle, "w-[150px] h-8 px-2 text-xs rounded")}> <Layers className='h-3 w-3 mr-1 text-gray-400' style={{ filter: `drop-shadow(0 0 3px ${NEON_COLOR}50)` }}/> <SelectValue placeholder="Campanha..." /> </SelectTrigger> <SelectContent className={cn(popoverContentStyle)}> <SelectItem value="none" className="text-xs text-muted-foreground hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">Sem Campanha</SelectItem> {campaignList.map(c => (<SelectItem key={c.id} value={c.id} className="text-xs hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">{c.name}</SelectItem>))} </SelectContent> </Select> <Input value={flowNameInput} onChange={(e) => setFlowNameInput(e.target.value)} placeholder="Nome do Fluxo" className={cn(baseInputInsetStyle, "h-8 text-xs w-[150px] rounded px-2")} disabled={isLoading} /> <Tooltip><TooltipTrigger asChild><Button onClick={toggleFlowStatus} variant="ghost" size="icon" className={cn(baseButtonSelectStyle, "w-8 h-8 rounded")} disabled={isLoading}>{isTogglingStatus ? <Activity className="h-4 w-4 animate-spin" style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR})` }}/> : (selectedFlow.status === 'active' ? <Square className="h-4 w-4 text-red-500" style={{ filter: `drop-shadow(0 0 3px #ef4444)` }}/> : <Play className="h-4 w-4 text-green-500" style={{ filter: `drop-shadow(0 0 3px #22c55e)` }}/>)}</Button></TooltipTrigger><TooltipContent className={cn(popoverContentStyle, 'text-xs')}>{selectedFlow.status === 'active' ? 'Desativar Fluxo' : 'Ativar Fluxo'}</TooltipContent></Tooltip> <Tooltip><TooltipTrigger asChild><Button onClick={saveFlow} variant="ghost" size="icon" className={cn(baseButtonSelectStyle, "w-8 h-8 rounded")} disabled={isLoading || !flowNameInput.trim()}>{isSaving ? <Activity className="h-4 w-4 animate-spin" style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR})` }}/> : <Save className="h-4 w-4" style={{ filter: `drop-shadow(0 0 3px ${NEON_COLOR})` }}/>}</Button></TooltipTrigger><TooltipContent className={cn(popoverContentStyle, 'text-xs')}>Salvar Fluxo</TooltipContent></Tooltip> <Tooltip><TooltipTrigger asChild><Button onClick={deleteSelectedFlow} variant="ghost" size="icon" className={cn(baseButtonSelectStyle, "w-8 h-8 rounded !text-red-400 hover:!bg-red-500/30")} disabled={isLoading}>{isDeleting ? <Activity className="h-4 w-4 animate-spin" style={{ filter: `drop-shadow(0 0 4px #ef4444)` }}/> : <IconTrash className="h-4 w-4" style={{ filter: `drop-shadow(0 0 3px #ef4444)` }}/>}</Button></TooltipTrigger><TooltipContent className={cn(popoverContentStyle, 'text-xs')}>Deletar Fluxo</TooltipContent></Tooltip> </> )}
                                         {!selectedFlow && !isLoadingFlowList && !isLoadingFlowDetails && <span className='text-xs text-gray-400 mr-2' style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>Selecione ou crie um fluxo</span>}
                                         {(isLoadingFlowList || isLoadingFlowDetails) && <Activity className="h-4 w-4 animate-spin text-gray-400 mr-2" style={{ filter: `drop-shadow(0 0 4px ${NEON_COLOR}50)` }}/>}
                                     </div>
                                    <Button onClick={createNewFlow} className={cn(baseButtonSelectStyle, `hover:!bg-[${NEON_COLOR}]/30 h-8 text-xs px-3 rounded`)} disabled={isLoading}> <Plus className="mr-1 h-4 w-4" style={{ filter: `drop-shadow(0 0 3px ${NEON_COLOR})` }}/> Novo </Button>
                                </div>
                                <div className="flex-grow relative h-full" ref={reactFlowWrapper}>
                                     {reactFlowInstance ? ( <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} onEdgesChange={onEdgesChange} onConnect={onConnect} nodeTypes={nodeTypes} fitView={!initialFlowLoaded} fitViewOptions={{ padding: 0.3 }} className="bg-transparent" proOptions={{ hideAttribution: true }} deleteKeyCode={['Backspace', 'Delete']} onNodeContextMenu={handleNodeContextMenu} onPaneClick={handlePaneClick} nodesDraggable={!isLoading && !!selectedFlow} nodesConnectable={!isLoading && !!selectedFlow} elementsSelectable={!isLoading && !!selectedFlow} > <Controls className={cn(baseButtonSelectStyle, '!border-none !shadow-none flex flex-col gap-0.5 !bg-opacity-80 backdrop-blur-sm')} /> <MiniMap className={cn(baseCardStyle, '!border-[#1E90FF]/20 rounded-md overflow-hidden')} nodeStrokeWidth={3} zoomable pannable nodeColor="#1E90FF80" maskColor="rgba(26,26,26,0.7)" /> <Background variant={BackgroundVariant.Dots} gap={16} size={1} className={`!stroke-[#1E90FF]/15`} /> {contextMenu && <NodeContextMenu id={contextMenu.id} top={contextMenu.top} left={contextMenu.left} nodeType={contextMenu.nodeType} onClose={handlePaneClick} onDelete={handleDeleteNode} onDuplicate={handleDuplicateNode} />} </ReactFlow> ) : ( <div className="flex items-center justify-center h-full text-gray-400" style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}> Carregando editor... </div> )}
                                     {isLoading && <div className="absolute inset-0 bg-black/70 flex items-center justify-center text-white z-10 backdrop-blur-sm"><Activity className="h-6 w-6 animate-spin mr-2" style={{ filter: `drop-shadow(0 0 5px ${NEON_COLOR})` }}/> Processando...</div>}
                                     {!selectedFlow && !isLoading && <div className="absolute inset-0 bg-black/70 flex items-center justify-center text-white z-10 backdrop-blur-sm text-sm" style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}>Selecione ou crie um fluxo para começar.</div>}
                                </div>
                            </div>
                        </TabsContent>

                        <TabsContent value="contacts" className="flex-grow flex flex-col space-y-3 m-0 p-0 border-none rounded-lg overflow-hidden min-h-0">
                            <Card className={cn(baseCardStyle, "flex flex-col h-full")}>
                                <CardHeader className="flex-shrink-0 border-b border-[#1E90FF]/20 pb-2">
                                    <div className="flex justify-between items-center">
                                        <CardTitle className="text-base font-semibold text-white flex items-center" style={{ textShadow: `0 0 5px ${NEON_COLOR}` }}>
                                            <IconWithGlow icon={Users} className="mr-2 h-5 w-5"/> Contatos ({contacts.length})
                                        </CardTitle>
                                        <Tooltip>
                                            <TooltipTrigger asChild>
                                                <Button
                                                    variant="ghost"
                                                    size="icon"
                                                    onClick={() => {
                                                        if (contactFetchTimeoutId) clearTimeout(contactFetchTimeoutId);
                                                        setContactFetchTimeoutId(null);
                                                        setHasAttemptedContactFetch(false);
                                                        fetchContacts();
                                                    }}
                                                    disabled={!isConnected || isLoadingContacts}
                                                    className={cn(baseButtonSelectStyle, "w-8 h-8 rounded")}
                                                >
                                                    {isLoadingContacts ? <Activity className="h-4 w-4 animate-spin" /> : <RefreshCw className="h-4 w-4" />}
                                                </Button>
                                            </TooltipTrigger>
                                            <TooltipContent className={cn(popoverContentStyle, 'text-xs')}>Atualizar Lista</TooltipContent>
                                        </Tooltip>
                                    </div>
                                     <div className="relative mt-2">
                                        <Search className="absolute left-2 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
                                        <Input
                                            type="search"
                                            placeholder="Buscar por nome ou número..."
                                            value={searchTerm}
                                            onChange={(e) => setSearchTerm(e.target.value)}
                                            className={cn(baseInputInsetStyle, "h-8 text-xs rounded pl-8")}
                                            disabled={!isConnected && !isLoadingContacts}
                                        />
                                    </div>
                                </CardHeader>
                                <CardContent className="flex-grow p-0 overflow-hidden">
                                    <ScrollArea className="h-full">
                                        <div className="p-3 space-y-2">
                                            {!isConnected ? (
                                                <p className='text-gray-400 text-center text-xs py-10' style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>Conecte o WhatsApp para ver os contatos.</p>
                                            ) : isLoadingContacts ? (
                                                <div className='flex justify-center items-center py-10'>
                                                    <Activity className="h-5 w-5 animate-spin mr-2 text-[#1E90FF]" style={{ filter: `drop-shadow(0 0 5px ${NEON_COLOR})` }}/>
                                                    <p className="text-gray-400 text-sm" style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>Carregando contatos...</p>
                                                </div>
                                            ) : contacts.length === 0 && hasAttemptedContactFetch ? (
                                                 <p className='text-gray-400 text-center text-xs py-10' style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>
                                                     Nenhum contato sincronizado encontrado.<br/>Tente atualizar ou verifique os logs do bot.
                                                 </p>
                                            ) : filteredContacts.length === 0 && searchTerm ? (
                                                  <p className='text-gray-400 text-center text-xs py-10' style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>
                                                     Nenhum contato encontrado para "{searchTerm}".
                                                  </p>
                                            ) : filteredContacts.length === 0 && !hasAttemptedContactFetch && !isLoadingContacts ? (
                                                <p className='text-gray-400 text-center text-xs py-10' style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>
                                                     Clique em <RefreshCw className="inline h-3 w-3 mx-1" /> para carregar os contatos.
                                                  </p>
                                            ) : (
                                                filteredContacts.map(contact => (
                                                    <div key={contact.jid} className={cn(baseCardStyle, 'p-2 flex items-center space-x-3 hover:bg-[#1E90FF]/10 transition-colors duration-150 rounded-md cursor-default')}>
                                                        <div className="w-6 h-6 rounded-full bg-gray-700 flex items-center justify-center flex-shrink-0"> <UserCircle className="h-4 w-4 text-gray-400" /> </div>
                                                        <div className="flex-grow overflow-hidden">
                                                            <p className="text-xs font-medium text-white truncate" title={contact.name || contact.notify || contact.jid.split('@')[0]} style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}>{contact.name || contact.notify || 'Nome Desconhecido'}</p>
                                                            <p className="text-[10px] text-gray-400" title={contact.jid} style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}>{contact.jid.split('@')[0]}</p>
                                                        </div>
                                                         <Tooltip>
                                                            {/* Correção: Remover asChild */}
                                                             <TooltipTrigger>
                                                                 <Button variant="ghost" size="icon" className={cn(baseButtonSelectStyle, "w-6 h-6 rounded hover:!bg-[${NEON_COLOR}]/30")} onClick={() => alert(`Iniciar conversa com ${contact.jid} (Não implementado)`)}>
                                                                     <Send className="h-3 w-3" />
                                                                 </Button>
                                                             </TooltipTrigger>
                                                             <TooltipContent className={cn(popoverContentStyle, 'text-xs')}>Enviar Mensagem</TooltipContent>
                                                         </Tooltip>
                                                    </div>
                                                ))
                                            )}
                                        </div>
                                    </ScrollArea>
                                </CardContent>
                            </Card>
                        </TabsContent>

                        <TabsContent value="settings" className="flex-grow overflow-y-auto space-y-4 pr-1 custom-scrollbar min-h-0">
                             <Card className={cn(baseCardStyle)}>
                                <CardHeader>
                                    <CardTitle className="text-base font-semibold text-white flex items-center" style={{ textShadow: `0 0 5px ${NEON_COLOR}` }}>
                                        <IconWithGlow icon={Settings} className="mr-2 h-5 w-5"/>Configurações Gerais
                                    </CardTitle>
                                    <CardDescription className="text-xs text-gray-400" style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}>Ajustes globais do comportamento do bot.</CardDescription>
                                </CardHeader>
                                <CardContent className="space-y-5">
                                    <div className="space-y-3">
                                        <h4 className='text-sm font-medium text-white border-b border-[#1E90FF]/20 pb-1 mb-2' style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}>Comportamento</h4>
                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-3 items-center">
                                            <div className="space-y-1">
                                                <Label className="text-xs text-gray-300 flex items-center" htmlFor="defaultDelay" style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}><Clock className="mr-1.5 h-3.5 w-3.5"/> Atraso Padrão (ms)</Label>
                                                <Input id="defaultDelay" type="number" value={settings.defaultMessageDelayMs} onChange={(e) => handleSettingChange('defaultMessageDelayMs', parseInt(e.target.value) || 0)} className={cn(baseInputInsetStyle, "h-8 text-xs rounded")} placeholder="Ex: 500" />
                                            </div>
                                            <div className="space-y-1">
                                                <Label className="text-xs text-gray-300 flex items-center" htmlFor="inputTimeout" style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}><Hourglass className="mr-1.5 h-3.5 w-3.5"/> Timeout Espera Input (s)</Label>
                                                <Input id="inputTimeout" type="number" value={settings.defaultInputTimeoutSeconds} onChange={(e) => handleSettingChange('defaultInputTimeoutSeconds', parseInt(e.target.value) || 0)} className={cn(baseInputInsetStyle, "h-8 text-xs rounded")} placeholder="Ex: 60" />
                                            </div>
                                            <div className="space-y-1">
                                                <Label className="text-xs text-gray-300 flex items-center" htmlFor="unknownResponse" style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}><HelpCircle className="mr-1.5 h-3.5 w-3.5"/> Msg Desconhecida</Label>
                                                <Select value={settings.unknownMessageResponse} onValueChange={(v: AppSettings['unknownMessageResponse']) => handleSettingChange('unknownMessageResponse', v)}>
                                                    <SelectTrigger id="unknownResponse" className={cn(baseButtonSelectStyle, "h-8 text-xs rounded")}> <SelectValue /> </SelectTrigger>
                                                    <SelectContent className={cn(popoverContentStyle)}>
                                                        <SelectItem value="ignore" className="text-xs hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">Ignorar</SelectItem>
                                                        <SelectItem value="defaultReply" className="text-xs hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">Resposta Padrão</SelectItem>
                                                        <SelectItem value="forwardAdmin" className="text-xs hover:!bg-[rgba(30,144,255,0.2)] focus:!bg-[rgba(30,144,255,0.2)]">Encaminhar Admin</SelectItem>
                                                    </SelectContent>
                                                </Select>
                                            </div>
                                            {settings.unknownMessageResponse === 'forwardAdmin' && (
                                                <div className="space-y-1">
                                                    <Label className="text-xs text-gray-300 flex items-center" htmlFor="adminNumber" style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}><Smartphone className="mr-1.5 h-3.5 w-3.5"/> Nº Admin (JID)</Label>
                                                    <Input id="adminNumber" value={settings.adminForwardNumber} onChange={(e) => handleSettingChange('adminForwardNumber', e.target.value)} className={cn(baseInputInsetStyle, "h-8 text-xs rounded")} placeholder="5511999998888@s.whatsapp.net" />
                                                </div>
                                            )}
                                        </div>
                                        {settings.unknownMessageResponse === 'defaultReply' && (
                                            <div className="space-y-1">
                                                <Label className="text-xs text-gray-300 flex items-center" htmlFor="defaultReplyMsg" style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}><Send className="mr-1.5 h-3.5 w-3.5"/> Mensagem Padrão</Label>
                                                <Textarea id="defaultReplyMsg" value={settings.defaultReplyMessage} onChange={(e) => handleSettingChange('defaultReplyMessage', e.target.value)} className={cn(baseInputInsetStyle, "text-xs rounded min-h-[60px]")} placeholder="Sua mensagem padrão..." rows={2} />
                                            </div>
                                        )}
                                    </div>
                                    <div className="space-y-3 pt-3 border-t border-[#1E90FF]/10">
                                        <div className='flex justify-between items-center'>
                                            <h4 className='text-sm font-medium text-white' style={{ textShadow: `0 0 4px ${NEON_COLOR}` }}>Horário Comercial</h4>
                                            <Switch id="enableBusinessHours" checked={settings.enableBusinessHours} onCheckedChange={(checked) => handleSettingChange('enableBusinessHours', checked)} className="data-[state=checked]:bg-green-600 data-[state=unchecked]:bg-gray-600 border-transparent" />
                                        </div>
                                        {settings.enableBusinessHours && (
                                            <div className="space-y-3">
                                                 <div className="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-3 items-center">
                                                    <div className="space-y-1">
                                                        <Label className="text-xs text-gray-300 flex items-center" htmlFor="bhStart" style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}><Play className="mr-1.5 h-3.5 w-3.5"/> Início (HH:MM)</Label>
                                                        <Input id="bhStart" type="time" value={settings.businessHoursStart} onChange={(e) => handleSettingChange('businessHoursStart', e.target.value)} className={cn(baseInputInsetStyle, "h-8 text-xs rounded")} />
                                                    </div>
                                                    <div className="space-y-1">
                                                        <Label className="text-xs text-gray-300 flex items-center" htmlFor="bhEnd" style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}><Square className="mr-1.5 h-3.5 w-3.5"/> Fim (HH:MM)</Label>
                                                        <Input id="bhEnd" type="time" value={settings.businessHoursEnd} onChange={(e) => handleSettingChange('businessHoursEnd', e.target.value)} className={cn(baseInputInsetStyle, "h-8 text-xs rounded")} />
                                                    </div>
                                                 </div>
                                                <div className="space-y-1">
                                                    <Label className="text-xs text-gray-300 flex items-center" htmlFor="outsideHoursMsg" style={{ textShadow: `0 0 3px ${NEON_COLOR}50` }}><Send className="mr-1.5 h-3.5 w-3.5"/> Mensagem Fora do Horário</Label>
                                                    <Textarea id="outsideHoursMsg" value={settings.outsideHoursMessage} onChange={(e) => handleSettingChange('outsideHoursMessage', e.target.value)} className={cn(baseInputInsetStyle, "text-xs rounded min-h-[60px]")} placeholder="Sua mensagem fora do horário..." rows={2} />
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                     <div className="flex justify-end pt-4 border-t border-[#1E90FF]/10">
                                         <Button onClick={saveSettings} className={cn(baseButtonSelectStyle, `hover:!bg-[${NEON_COLOR}]/30 h-9 text-sm px-4 rounded`)} disabled={isSavingSettings}>
                                            {isSavingSettings ? <Activity className="mr-2 h-4 w-4 animate-spin" /> : <Save className="mr-2 h-4 w-4" />}
                                            {isSavingSettings ? "Salvando..." : "Salvar Configurações"}
                                         </Button>
                                     </div>
                                </CardContent>
                             </Card>
                            <Card className={cn(baseCardStyle)}>
                                <CardHeader><CardTitle className="text-base font-semibold text-white flex items-center" style={{ textShadow: `0 0 5px ${NEON_COLOR}` }}><Bell className="mr-2 h-5 w-5"/> Notificações</CardTitle></CardHeader>
                                <CardContent><p className='text-gray-400 text-xs' style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>Configurações de notificação (ex: erros, novas mensagens) - Implementação futura.</p></CardContent>
                            </Card>
                             <Card className={cn(baseCardStyle)}>
                                <CardHeader><CardTitle className="text-base font-semibold text-white flex items-center" style={{ textShadow: `0 0 5px ${NEON_COLOR}` }}><ShieldCheck className="mr-2 h-5 w-5"/> Segurança & API</CardTitle></CardHeader>
                                <CardContent><p className='text-gray-400 text-xs' style={{ textShadow: `0 0 4px ${NEON_COLOR}50` }}>Configurações de chaves de API e segurança - Implementação futura.</p></CardContent>
                            </Card>
                        </TabsContent>
                    </Tabs>
                </main>
            </div>
        </TooltipProvider>
    );
}

// --- Componente Wrapper com Provider ---
export default function WhatsAppPage() {
    return (
        <ReactFlowProvider>
            <WhatsAppFlowEditor />
        </ReactFlowProvider>
    );
}